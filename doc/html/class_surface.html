<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NanoShaper: Surface Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">NanoShaper
   &#160;<span id="projectnumber">0.7.2</span>
   </div>
   <div id="projectbrief">NanoShaper is a tool able to triangulate and inspect an arbitray triangulated surface or several types of molecular surfaces</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_surface.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Surface Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Surface" -->
<p><a class="el" href="class_surface.html" title="Surface class is the general interface that a surface class should have to be plugged inside DelPhi...">Surface</a> class is the general interface that a surface class should have to be plugged inside DelPhi. Some functions implementations are mandatory such as load, save, build, etc... Note that the surface is not necessarly a molecular surface. Build function computes an internal representation of the surface; getSurf translates that representation in the DelPhi compatible representation. Note that in order to put a new surface in DelPhi a surface must provide epsmap, idebmap, computations of the surface area inside a grid cube, identification and projections of boundary grid points and their surface normals; these computations must be done in getSurf while the surface construction must be performed in build. <br/>
 <br/>
.  
 <a href="class_surface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_surface_8h_source.html">Surface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Surface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_surface.png" usemap="#Surface_map" alt=""/>
  <map id="Surface_map" name="Surface_map">
<area href="class_connolly_surface.html" title="This class builds and converts to a DelPhi suitable representation the Connolly-Richards Surface..." alt="ConnollySurface" shape="rect" coords="0,56,143,80"/>
<area href="class_example_surface.html" title="This class is a simple example that shows the main concepts needed to introduce a new surface in Nano..." alt="ExampleSurface" shape="rect" coords="153,56,296,80"/>
<area href="class_external_surface.html" title="This class is wrapper and loads an external surface using the files epsmapx.txt, epsmapy.txt, epsmapz.txt, status.txt and projections.txt that is the list of the boundary grid points indexes,values and normals." alt="ExternalSurface" shape="rect" coords="306,56,449,80"/>
<area href="class_f_van_der_waals_surface.html" title="This class builds the Van Der Waals surface as the union of the set of spheres in a fast way: the sur..." alt="FVanDerWaalsSurface" shape="rect" coords="459,56,602,80"/>
<area href="class_mesh_surface.html" title="This class represents a converter from an arbitray triangulated mesh surface to a DelPhi compatible r..." alt="MeshSurface" shape="rect" coords="612,56,755,80"/>
<area href="class_skin_surface.html" title="This class builds and converts to a DelPhi suitable representation the Skin Surface. All the gathered info is analytically computed both the intersections and the projections. In order to get an accurate result for the projection routine, as root finding algorithm is used the method of the companion matrix. The Skin surface was defined in:  &quot;H. Edelsbrunner. Deformable smooth surface design. Discrete Comput. Geom., 21:87-115, 1999.&quot; " alt="SkinSurface" shape="rect" coords="765,56,908,80"/>
<area href="class_blobby_surface.html" title="This class builds the blobby surface, triangulate it and the use mesh surface routines for the rest o..." alt="BlobbySurface" shape="rect" coords="535,112,678,136"/>
<area href="class_coulombic_surface.html" title="This class builds the Coulombic surface, triangulate it and the use mesh surface routines for the res..." alt="CoulombicSurface" shape="rect" coords="688,112,831,136"/>
</map>
 </div></div>

<p><a href="class_surface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aa2a574672fef1eec8dca5855e002a6fa">build</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a2751d5daca6a1c766f8f8f6b34685177">save</a> (char *fileName)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a8c76d22fd2fb86243d8c0462e1a93d40">load</a> (char *fileName)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a301e2ea2fb4b9502f00095de103a462d">printSummary</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a6abcfb3f49c88fc2874dd36242e73a14">getProjection</a> (double p[3], double *proj1, double *proj2, double *proj3, double *normal1, double *normal2, double *normal3)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ab726dc855b481fd5b7698027e7b18be1">getRayIntersection</a> (double p1[3], double p2[3], vector&lt; pair&lt; double, double * &gt; &gt; &amp;intersections, int thdID, bool computeNormals)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a4b74b0402a78369c8df85e6a6beaba93">init</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#afa9d3a3a984c8b576d2b9654546653aa">init</a> (ConfigFile *cf)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aeb711e5ba9c9ecf45aa97c889c72a204">clear</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a61c7bc2bf53b083d34304632cf33d87c">getSurf</a> (bool fill=false, double vol=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a6bdef0d8685e685849cccb1a463f68c0">getVolume</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a8aae0c97bcbaa1f9d93877b0928d5c39">getArea</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a86dea6c9d55d6a873d3a9c0ce403aa9f">getCavities</a> (int idStart=STATUS_POINT_TEMPORARY_OUT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aa4563ab244a65a028b3ea1f1ab048033">fillCavities</a> (double vol=0, bool silent=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a5b434ea42db19814d88d4c0f17c193d8">filterCavities</a> (bool modStatus=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a833a78b4400ed625653b6b946fa301ca">cav2out</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a05ae5d8c757297d2e71fcd15171957fb">triangulateSurface</a> (double iso=0.0, const char *fileName=&quot;triangulatedSurf&quot;, bool revert=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a6f52710c2460260d5342eb55060894e6">saveMesh</a> (int format, bool revert, const char *fileName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a30601580f9e6867aa9ee290378f9855b">smoothSurface</a> (const char *fn=&quot;triangulatedSurf&quot;, bool revert=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a5f9846a6cd988af5aa352b7562636802">preProcessPanel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae37064f017b7062b33d87de0c36b44cb">postRayCasting</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#af36ad1f0f24d82f3f77837a1e28998b5">preBoundaryProjection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a1e23cf166678a10006927c0753d754e3">tri2Balls</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a3596a32b41dfeadb527ecb865b191e63">backupStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#add2db5e19f03a4d40fb8ead92833c439">removeBackupStatus</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a40e97c43ed07d2f0f0e6a05c2935f9c5">linkCavities</a> (short *st1, short *st2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a9bcd947b84853a89d13dca5ac37cb245">difference</a> (<a class="el" href="class_surface.html">Surface</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_surface.html">Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae1129874da00ff0b1857591c0e179c6c">operator-=</a> (<a class="el" href="class_surface.html">Surface</a> &amp;surf2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a13f6e6a853796495fe53e5820069000f">getCavitiesAtoms</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a5a062749214cb7121ecab66ce979e163">setProjBGP</a> (bool flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8932e2decf6c59ecf3ea27cc684eadc5"></a><!-- doxytag: member="Surface::getProjBGP" ref="a8932e2decf6c59ecf3ea27cc684eadc5" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getProjBGP</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a315d5a649f7b7972769937099d205"></a><!-- doxytag: member="Surface::getSternLayer" ref="a41a315d5a649f7b7972769937099d205" args="()" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>getSternLayer</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d0aa59b0521561620d5a3b4bf667ce0"></a><!-- doxytag: member="Surface::setSternLayer" ref="a6d0aa59b0521561620d5a3b4bf667ce0" args="(double l)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSternLayer</b> (double l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a737be2dd7b21dbb3bbebb6b5cb0c8c65"></a><!-- doxytag: member="Surface::setSaveMSMS" ref="a737be2dd7b21dbb3bbebb6b5cb0c8c65" args="(bool m)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSaveMSMS</b> (bool m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b72146a98071703e83f7909f8bbfb16"></a><!-- doxytag: member="Surface::getSaveMSMS" ref="a0b72146a98071703e83f7909f8bbfb16" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getSaveMSMS</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa5a17c3f3fab2a94bb006a8d784c73"></a><!-- doxytag: member="Surface::setTriangulationFlag" ref="abfa5a17c3f3fab2a94bb006a8d784c73" args="(bool flag)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTriangulationFlag</b> (bool flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a692e3b27bbed93fc8ab85c897d5a85eb"></a><!-- doxytag: member="Surface::getTriangulationFlag" ref="a692e3b27bbed93fc8ab85c897d5a85eb" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getTriangulationFlag</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed3fad52ba7678121a55c6f8dd1c8b4"></a><!-- doxytag: member="Surface::setVertexAtomsMap" ref="aeed3fad52ba7678121a55c6f8dd1c8b4" args="(bool f)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setVertexAtomsMap</b> (bool f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6189a1982f700f008606471a22f6c02"></a><!-- doxytag: member="Surface::getVertexAtomsMap" ref="ab6189a1982f700f008606471a22f6c02" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexAtomsMap</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabf44735d489ac1d6db7773b22beb80a"></a><!-- doxytag: member="Surface::setComputeNormals" ref="aabf44735d489ac1d6db7773b22beb80a" args="(bool cn)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setComputeNormals</b> (bool cn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a536788ee42dbe4f8a6f928f78d742073"></a><!-- doxytag: member="Surface::getComputeNormals" ref="a536788ee42dbe4f8a6f928f78d742073" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getComputeNormals</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a513d254cab28e206c1bc1960f9447c46"></a><!-- doxytag: member="Surface::setCheckDuplicatedVertices" ref="a513d254cab28e206c1bc1960f9447c46" args="(bool cd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCheckDuplicatedVertices</b> (bool cd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfbbc2170d5a4d2ff758998f495b1864"></a><!-- doxytag: member="Surface::getCheckDuplicatedVertices" ref="adfbbc2170d5a4d2ff758998f495b1864" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getCheckDuplicatedVertices</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c4e6396e897ad1c69234cacf223806d"></a><!-- doxytag: member="Surface::setKeepWellShapedCavities" ref="a3c4e6396e897ad1c69234cacf223806d" args="(bool kwsc)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setKeepWellShapedCavities</b> (bool kwsc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae311833c8f0cb6bcbf47dd56bdf74660"></a><!-- doxytag: member="Surface::getKeepWellShapedCavities" ref="ae311833c8f0cb6bcbf47dd56bdf74660" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getKeepWellShapedCavities</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79a0933a447b0de85dc8bb3409012a7"></a><!-- doxytag: member="Surface::setProbeRadius" ref="ac79a0933a447b0de85dc8bb3409012a7" args="(double probeRadius)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setProbeRadius</b> (double probeRadius)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e87e7d4d2129f188782c14b2d728530"></a><!-- doxytag: member="Surface::getProbeRadius" ref="a0e87e7d4d2129f188782c14b2d728530" args="()" -->
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>getProbeRadius</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4463af517884bda030c759a6abb5b7a"></a><!-- doxytag: member="Surface::getRandDisplacement" ref="ac4463af517884bda030c759a6abb5b7a" args="()" -->
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>getRandDisplacement</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaac0bea6b896bfaa04670fe996fee148"></a><!-- doxytag: member="Surface::setRandDisplacement" ref="aaac0bea6b896bfaa04670fe996fee148" args="(const double r)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRandDisplacement</b> (const double r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b4ee9e3ab80a620bb50793fa15e8b8"></a><!-- doxytag: member="Surface::setLoadBalancing" ref="a24b4ee9e3ab80a620bb50793fa15e8b8" args="(bool doLoadBalancing)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setLoadBalancing</b> (bool doLoadBalancing)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7fa5e4cfc93ffd4b364bca704071d81"></a><!-- doxytag: member="Surface::getLoadBalancing" ref="aa7fa5e4cfc93ffd4b364bca704071d81" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>getLoadBalancing</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82bf8a725e1a08a4728c4873caedd7cc"></a><!-- doxytag: member="Surface::getNumTriangles" ref="a82bf8a725e1a08a4728c4873caedd7cc" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumTriangles</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316afec812467664f0aa6bf33df99c98"></a><!-- doxytag: member="Surface::getNumVertices" ref="a316afec812467664f0aa6bf33df99c98" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertices</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a453558bf8e2e7f5ff80030f38e0ae4c0"></a><!-- doxytag: member="Surface::setInsideCode" ref="a453558bf8e2e7f5ff80030f38e0ae4c0" args="(int i)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setInsideCode</b> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f7613e93ea355124a8472370c5047fe"></a><!-- doxytag: member="Surface::getInsideCode" ref="a5f7613e93ea355124a8472370c5047fe" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getInsideCode</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a89de75c95cb550d432f3ea4ed1429db0">~Surface</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a3a05f3c176bf48997e2bb80d93d12c1c">floodFill</a> (int ix, int iy, int iz, int idold, int idnew)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a2504c4633a17c850ba0b94986129482d">floodFill2</a> (int ix, int iy, int iz, int idold, int idnew)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a81bd694aaef6d8f81a3ec90fbada058e">floodFill4</a> (int ix, int iy, int iz, int idold, int idnew)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ac779a16f278c2a2310b427f02c65a934">floodFill3</a> (pair&lt; pair&lt; int, int &gt;, int &gt; ind, pair&lt; int, int &gt; z_limits, pair&lt; int, int &gt; old_new, pair&lt; queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; *, queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; * &gt; queues, queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; *in_queue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ab3e4ffdd402306e7ccba762b649f51ed">innerFloodFill</a> (int *start, int *target, short *status1, short *status2, int &amp;maxMoves, bool debug)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aead8b30ad88724d4542ee01bc5bef037">vdwAccessible</a> (double *p, int &amp;nearest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#abb28f2e5b95b8f374ddd9232f7fb7574">intersector</a> (double *volPanel, int nb, int start, int end, int jump, int *numIntersections, <a class="el" href="classpacket.html">packet</a> pack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aa1b0af28ebbd3078172873b403ae4b6b">projector</a> (int start, int end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a4e9dd2a3cd7fdd85887727ed477f74aa">getInsidness</a> (int i, int j, int k, int vertInd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a90a0436c049d155f2c9c4c46a564a660">vertexInterp</a> (double isolevel, double *p1, double *p2, double valp1, double valp2, double *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a44b184a84f4bb252cc1b9b60736c0946">getTriangles</a> (double *vertexValues, double **vertexPos, double isolevel, int **triangles, int ix, int iy, int iz, int NX, int NY, int NZ)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a17a6ff105dde2aeb5298bf86b88fab63">getVertices</a> (double isolevel, int start_z, int end_z, int jump, vector&lt; <a class="el" href="classcoord_vec.html">coordVec</a> &gt; *, vector&lt; double * &gt; *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae7b93c9dce0507fc68147f5fa826cc10">classifyCube</a> (double *vertexValues, double isolevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aaebf0a88b5a538d1abd508be83cddb96">approximateNormals</a> (vector&lt; int &gt; &amp;appNormals, bool doOnlyList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a37ccecb59c1809f99a642836fc3a85b9">triangulationKernel</a> (double isolevel, bool revert, int start_z, int end_z, int jump, vector&lt; int * &gt; *localTriList, double *localArea)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae360bbd9c25be5d92627b0a0bf8f5ce7">buildAtomsMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a7bcb3486fb24260fc3fccd97151852e8">disposeAtomsMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ad5c51dff2e0662d68057abf4882f9ef9">applyMultidielectric</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ab33c17df0587ec8fac0c43130cde651b">swap2multi</a> (double gxmin, double gymin, double gzmin, double gside, unsigned int ggrid, int *<a class="el" href="class_surface.html#a45d8207ef5dc33d9f58f75658f293489">gridMultiMap</a>, int i, int j, int k, int l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae01ec6774d68fb81b5b02edac7eb4b2f">buildSternLayer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a893bbc3b4208536d256076aa48a8f40f">allocIntersectionsMatrices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a9b4c4ff12611ec85696bc78e48b86e92">allocNormalsMatrices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a835334c2151e0439ca0adb26d3645649">deduceFormat</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7c2511545949ba1e4c9871398037e46"></a><!-- doxytag: member="Surface::Surface" ref="aa7c2511545949ba1e4c9871398037e46" args="(ConfigFile *cf)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>Surface</b> (ConfigFile *cf)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a70a2e5e21c918060a90ebeff6d4d845e">surfType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a6c2895b91dee0cb779c5f623b95e5fb9">isRCbased</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a1443e3d35892254a47633f1df92a8430">providesAnalyticalNormals</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b9ec638511da707033a61e9bc9fd3a"></a><!-- doxytag: member="Surface::projBGP" ref="a50b9ec638511da707033a61e9bc9fd3a" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>projBGP</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d870d0924530062ebc82b5233888ea8"></a><!-- doxytag: member="Surface::sternLayer" ref="a6d870d0924530062ebc82b5233888ea8" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>sternLayer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1866ef6458f2f0c2d6b02b51fca3bcec"></a><!-- doxytag: member="Surface::accurateTriangulation" ref="a1866ef6458f2f0c2d6b02b51fca3bcec" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>accurateTriangulation</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9fdd42177926e418717439976cf5447"></a><!-- doxytag: member="Surface::fillCavitiesFlag" ref="ac9fdd42177926e418717439976cf5447" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fillCavitiesFlag</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2541324172c78ddf09ea22efddd956ec"></a><!-- doxytag: member="Surface::computeNormals" ref="a2541324172c78ddf09ea22efddd956ec" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>computeNormals</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a574488ee98ebef52bb6fa4d25d8e9c34">checkDuplicatedVertices</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a4fe91bf0a47526c32f1b4b28cef45439">wellShaped</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aee9146cf4f2d57f70221153bb2a9b9cc">probe_radius</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081e8ce2d67d8d49cac4579ae823550d"></a><!-- doxytag: member="Surface::useLoadBalancing" ref="a081e8ce2d67d8d49cac4579ae823550d" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useLoadBalancing</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abca6550750e61ea9701f1826801126df"></a><!-- doxytag: member="Surface::vertexAtomsMapFlag" ref="abca6550750e61ea9701f1826801126df" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>vertexAtomsMapFlag</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd0fc7081147564aee2712a2017aed31"></a><!-- doxytag: member="Surface::saveMSMS" ref="acd0fc7081147564aee2712a2017aed31" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>saveMSMS</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005933888a9fb1feb7092fff100208c2"></a><!-- doxytag: member="Surface::panel" ref="a005933888a9fb1feb7092fff100208c2" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>panel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56bd1f0b2e4ea07960e2b1be0bb0e427"></a><!-- doxytag: member="Surface::delphi" ref="a56bd1f0b2e4ea07960e2b1be0bb0e427" args="" -->
<a class="el" href="class_del_phi_shared.html">DelPhiShared</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>delphi</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d2716d10d1de06dc17ea10a751a161"></a><!-- doxytag: member="Surface::totalSurfaceArea" ref="ad2d2716d10d1de06dc17ea10a751a161" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>totalSurfaceArea</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a445a73dc291f81a0f4aede945132292e"></a><!-- doxytag: member="Surface::totalVolume" ref="a445a73dc291f81a0f4aede945132292e" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>totalVolume</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad536c1348d09fae7f9aebf60ad76f055"></a><!-- doxytag: member="Surface::last_rows_ind" ref="ad536c1348d09fae7f9aebf60ad76f055" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_rows_ind</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a404ad6963bc1cc8c09c088ea890855c0"></a><!-- doxytag: member="Surface::last_cols_ind" ref="a404ad6963bc1cc8c09c088ea890855c0" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_cols_ind</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a4632ae2d850db8721d1a047159034c0d">randDisplacement</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b958ebf80bb92ebb32c5efe962c6fc"></a><!-- doxytag: member="Surface::last_nx" ref="a96b958ebf80bb92ebb32c5efe962c6fc" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_nx</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d1b7eefaa9e6c1b2807ebec87b66c6c"></a><!-- doxytag: member="Surface::last_ny" ref="a6d1b7eefaa9e6c1b2807ebec87b66c6c" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_ny</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50dd8042c35157edc7687abd251def3b"></a><!-- doxytag: member="Surface::last_nz" ref="a50dd8042c35157edc7687abd251def3b" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>last_nz</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Octree&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a98714879238042d7515497fbd78e0e85">intersectionsMatrixAlongX</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Octree&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae5d6e25842d3f00ed491bc3fd5508820">intersectionsMatrixAlongY</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Octree&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#ae1277d3fa42afd57392d99892d262e3a">intersectionsMatrixAlongZ</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Octree&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a326788a7b067f52c07753504e04396db">normalsMatrixAlongX</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Octree&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#add2c136b467697e7a7da833cd76283be">normalsMatrixAlongY</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Octree&lt; int &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aff65b5bcd2ef767b8725b8aa9c2211d6">normalsMatrixAlongZ</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a6c45be42398b0f466b9a4e2af961ea06">activeCubes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b2a09ec27843ac536a90f64e4cd11e"></a><!-- doxytag: member="Surface::verticesInsidenessMap" ref="a96b2a09ec27843ac536a90f64e4cd11e" args="" -->
bool ***&#160;</td><td class="memItemRight" valign="bottom"><b>verticesInsidenessMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07c094dc74967227fb0cb03c140f7f9d"></a><!-- doxytag: member="Surface::scalarField" ref="a07c094dc74967227fb0cb03c140f7f9d" args="" -->
double ***&#160;</td><td class="memItemRight" valign="bottom"><b>scalarField</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a610612e16322a63ecce624d282fab216"></a><!-- doxytag: member="Surface::isAvailableScalarField" ref="a610612e16322a63ecce624d282fab216" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAvailableScalarField</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; int * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aab49d3b34cdd33528617da0a4efc62d0">triList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#aefcae5a542a8333a04babe1ba7931b19">vertList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a788497ff41d053c1b9ead2708651a356">normalsList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af615aecbd0de548a64083c83cba36cde"></a><!-- doxytag: member="Surface::delta_accurate_triangulation" ref="af615aecbd0de548a64083c83cba36cde" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>delta_accurate_triangulation</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a8e1c15969548e4d1230904b87ff73b0c">bgp_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a45d8207ef5dc33d9f58f75658f293489">gridMultiMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5974b98911d3eac519c9c3fa3f127f"></a><!-- doxytag: member="Surface::gxmin" ref="a0b5974b98911d3eac519c9c3fa3f127f" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>gxmin</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69a67e4a94f24d7762ddc58ba51fbfb2"></a><!-- doxytag: member="Surface::gymin" ref="a69a67e4a94f24d7762ddc58ba51fbfb2" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>gymin</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884ddd7925aca17b124670d31dd36e77"></a><!-- doxytag: member="Surface::gzmin" ref="a884ddd7925aca17b124670d31dd36e77" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>gzmin</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a980d574da6d2640d593bf75455514604"></a><!-- doxytag: member="Surface::gside" ref="a980d574da6d2640d593bf75455514604" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>gside</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf8151fdebc2a7fac4a3e19b3c45a9a2"></a><!-- doxytag: member="Surface::gscale" ref="acf8151fdebc2a7fac4a3e19b3c45a9a2" args="" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>gscale</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a511e79877150e5fe8bffb4a87e458"></a><!-- doxytag: member="Surface::ggrid" ref="af4a511e79877150e5fe8bffb4a87e458" args="" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>ggrid</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a6b6bee2350f00c90e92ee0c9f1d82141">gridLoad</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeebca50c04b5e5a2fb10871695997bf4"></a><!-- doxytag: member="Surface::totalLoad" ref="aeebca50c04b5e5a2fb10871695997bf4" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>totalLoad</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea93f1a6d4708de4b4cb39a419719395"></a><!-- doxytag: member="Surface::vertexAtomsMap" ref="aea93f1a6d4708de4b4cb39a419719395" args="" -->
int *&#160;</td><td class="memItemRight" valign="bottom"><b>vertexAtomsMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_surface.html#a4a0e0047b72f2cbd187389f01d69b3c3">inside</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_surface.html" title="Surface class is the general interface that a surface class should have to be plugged inside DelPhi...">Surface</a> class is the general interface that a surface class should have to be plugged inside DelPhi. Some functions implementations are mandatory such as load, save, build, etc... Note that the surface is not necessarly a molecular surface. Build function computes an internal representation of the surface; getSurf translates that representation in the DelPhi compatible representation. Note that in order to put a new surface in DelPhi a surface must provide epsmap, idebmap, computations of the surface area inside a grid cube, identification and projections of boundary grid points and their surface normals; these computations must be done in getSurf while the surface construction must be performed in build. <br/>
 <br/>
. </p>
<p>The global variables in the <a class="el" href="class_del_phi_shared.html" title="This class is the DelPhi Shared variables environment which emulates the DelPhi environment.">DelPhiShared</a> object that must be filled are: <br/>
 idebmap -&gt; salt (in/out) map <br/>
 epsmap -&gt; dielectric map <br/>
 ibgp -&gt; indexes of the boundary grid points <br/>
 scspos -&gt; coordinates of the projected boundary grid points <br/>
 scsnor -&gt; coordinates of the outside pointing normal vector over the surface in correspondence of boundary grid points <br/>
 scsarea -&gt; value of the surface area in each cube of the grid where there is a boundary grid point (optional)<br/>
</p>
<p>If a new surface is defined and it only provides the routines of ray intersection and projection then most information can be still built; in this case one should not overload the getSurf method that in its base implementation is able to use projections/intersections to build almost all info needed by DelPhi to work; however this mode of operating has restrictions in fact only two dielectrics can be used (in/out) and the Stern layer (idebmap) is only in/out; this mode is used in the <a class="el" href="class_mesh_surface.html" title="This class represents a converter from an arbitray triangulated mesh surface to a DelPhi compatible r...">MeshSurface</a> class where an arbitrary shape is loaded or by the <a class="el" href="class_skin_surface.html" title="This class builds and converts to a DelPhi suitable representation the Skin Surface. All the gathered info is analytically computed both the intersections and the projections. In order to get an accurate result for the projection routine, as root finding algorithm is used the method of the companion matrix. The Skin surface was defined in:  &quot;H. Edelsbrunner. Deformable smooth surface design. Discrete Comput. Geom., 21:87-115, 1999.&quot; ">SkinSurface</a> module. Note that there is no need for the surface (or surface patches) to answer in/out queries; indeed in/out is worked out by counting the number of times the ray intersects the surface starting from the outside.</p>
<p>To get a full implementation one has to derive the <a class="el" href="class_surface.html" title="Surface class is the general interface that a surface class should have to be plugged inside DelPhi...">Surface</a> class and re-implement the interface method load,save,build and getSurf (or ray/projections routine) thus providing all the necessary info to DelPhi solver.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Sergio Decherchi </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>29/06/2013 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a89de75c95cb550d432f3ea4ed1429db0"></a><!-- doxytag: member="Surface::~Surface" ref="a89de75c95cb550d432f3ea4ed1429db0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Surface::~Surface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a893bbc3b4208536d256076aa48a8f40f"></a><!-- doxytag: member="Surface::allocIntersectionsMatrices" ref="a893bbc3b4208536d256076aa48a8f40f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::allocIntersectionsMatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clean and alloc intersections </p>

</div>
</div>
<a class="anchor" id="a9b4c4ff12611ec85696bc78e48b86e92"></a><!-- doxytag: member="Surface::allocNormalsMatrices" ref="a9b4c4ff12611ec85696bc78e48b86e92" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::allocNormalsMatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clean and alloc normals </p>

</div>
</div>
<a class="anchor" id="ad5c51dff2e0662d68057abf4882f9ef9"></a><!-- doxytag: member="Surface::applyMultidielectric" ref="ad5c51dff2e0662d68057abf4882f9ef9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::applyMultidielectric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>apply multidielectric correction after grid building. For each internal grid point detect the nearest atom and apply its dielectric constant. </p>

</div>
</div>
<a class="anchor" id="aaebf0a88b5a538d1abd508be83cddb96"></a><!-- doxytag: member="Surface::approximateNormals" ref="aaebf0a88b5a538d1abd508be83cddb96" args="(vector&lt; int &gt; &amp;appNormals, bool doOnlyList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::approximateNormals </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>appNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doOnlyList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>approximate normals based on the surrounding triangle planes normals </p>

</div>
</div>
<a class="anchor" id="a3596a32b41dfeadb527ecb865b191e63"></a><!-- doxytag: member="Surface::backupStatus" ref="a3596a32b41dfeadb527ecb865b191e63" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::backupStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>save current status map in a temporary map </p>

</div>
</div>
<a class="anchor" id="aa2a574672fef1eec8dca5855e002a6fa"></a><!-- doxytag: member="Surface::build" ref="aa2a574672fef1eec8dca5855e002a6fa" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build the surface internal representation. Returns if the building process was succesful or not </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#a4646020bc50daf31cd41537b0dec5f7a">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#abfee1006aa6f711774fffd9e94b95402">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#af652050d6e8fb903fce01bf7774fe3fb">MeshSurface</a>, <a class="el" href="class_example_surface.html#a2205276cd4857e373cff77e8064be7a1">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a86d7c7239918910fe0fa5553e24e4a46">FVanDerWaalsSurface</a>, <a class="el" href="class_coulombic_surface.html#abb9fc7346041f1f820d1ddaba4fd91b6">CoulombicSurface</a>, <a class="el" href="class_blobby_surface.html#a994122f16490d95adeb6dfdc34312161">BlobbySurface</a>, and <a class="el" href="class_external_surface.html#adb1e34217c1cd4672cce379b0c9efc2a">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae360bbd9c25be5d92627b0a0bf8f5ce7"></a><!-- doxytag: member="Surface::buildAtomsMap" ref="ae360bbd9c25be5d92627b0a0bf8f5ce7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::buildAtomsMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>build a 3D grid for acellerating nearest atom queries </p>

</div>
</div>
<a class="anchor" id="ae01ec6774d68fb81b5b02edac7eb4b2f"></a><!-- doxytag: member="Surface::buildSternLayer" ref="ae01ec6774d68fb81b5b02edac7eb4b2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::buildSternLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>build stern layer. </p>

</div>
</div>
<a class="anchor" id="a833a78b4400ed625653b6b946fa301ca"></a><!-- doxytag: member="Surface::cav2out" ref="a833a78b4400ed625653b6b946fa301ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::cav2out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>swap cavity status to temporary out </p>

</div>
</div>
<a class="anchor" id="ae7b93c9dce0507fc68147f5fa826cc10"></a><!-- doxytag: member="Surface::classifyCube" ref="ae7b93c9dce0507fc68147f5fa826cc10" args="(double *vertexValues, double isolevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::classifyCube </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vertexValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isolevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>gives MC cube index. If !=-1 then that cube contains triangles </p>

</div>
</div>
<a class="anchor" id="aeb711e5ba9c9ecf45aa97c889c72a204"></a><!-- doxytag: member="Surface::clear" ref="aeb711e5ba9c9ecf45aa97c889c72a204" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>function for the denstructor </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#a18c6f424c05f75544fabab0720593dda">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#a346203efe25d6a44d7bb3c27fe53978d">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#aeddfd2c0e5383b03d3040df455e810e1">MeshSurface</a>, <a class="el" href="class_example_surface.html#ad045118e1dafae031e71e22b06f3d56e">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a92321cf67e57897ad024bd05e656c950">FVanDerWaalsSurface</a>, <a class="el" href="class_external_surface.html#ad36f49d65eff9348020be1d03c14574d">ExternalSurface</a>, <a class="el" href="class_coulombic_surface.html#ad41909376783eca35870da81137b0902">CoulombicSurface</a>, and <a class="el" href="class_blobby_surface.html#a98d0fa2d2a2795049df2445b8a363233">BlobbySurface</a>.</p>

</div>
</div>
<a class="anchor" id="a835334c2151e0439ca0adb26d3645649"></a><!-- doxytag: member="Surface::deduceFormat" ref="a835334c2151e0439ca0adb26d3645649" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::deduceFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>based on provided info decides the best format to save the mesh </p>

</div>
</div>
<a class="anchor" id="a9bcd947b84853a89d13dca5ac37cb245"></a><!-- doxytag: member="Surface::difference" ref="a9bcd947b84853a89d13dca5ac37cb245" args="(Surface *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> *&#160;</td>
          <td class="paramname"><em>surf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>difference operator: said S1 the first surface (big probe), S2 (small probe) the second surface and S3 the output surface then the difference rule is the following rule: if S1 is not OUT and and S2 is OUT then that's the pocket </p>

</div>
</div>
<a class="anchor" id="a7bcb3486fb24260fc3fccd97151852e8"></a><!-- doxytag: member="Surface::disposeAtomsMap" ref="a7bcb3486fb24260fc3fccd97151852e8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::disposeAtomsMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>deallocate memory of the 3D nearest atom query </p>

</div>
</div>
<a class="anchor" id="aa4563ab244a65a028b3ea1f1ab048033"></a><!-- doxytag: member="Surface::fillCavities" ref="aa4563ab244a65a028b3ea1f1ab048033" args="(double vol=0, bool silent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::fillCavities </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the previously detected cavities if their volume is bigger that the passed var. In the baseline implementation the volume is approximated by the number of grid cubes volumes in that cavity. By default all cavities are filled </p>

</div>
</div>
<a class="anchor" id="a5b434ea42db19814d88d4c0f17c193d8"></a><!-- doxytag: member="Surface::filterCavities" ref="a5b434ea42db19814d88d4c0f17c193d8" args="(bool modStatus=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::filterCavities </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>modStatus</em> = <code>false</code></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After the cavities are detected and marked this routine filter out the part or the entire cavities that are not able to fit the bounding box of a water molecule. That is we filter the bad shaped cavities </p>

</div>
</div>
<a class="anchor" id="a3a05f3c176bf48997e2bb80d93d12c1c"></a><!-- doxytag: member="Surface::floodFill" ref="a3a05f3c176bf48997e2bb80d93d12c1c" args="(int ix, int iy, int iz, int idold, int idnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::floodFill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d cavity detection</p>
<p>queue based implementation </p>

</div>
</div>
<a class="anchor" id="a2504c4633a17c850ba0b94986129482d"></a><!-- doxytag: member="Surface::floodFill2" ref="a2504c4633a17c850ba0b94986129482d" args="(int ix, int iy, int iz, int idold, int idnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::floodFill2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>scan line version </p>

</div>
</div>
<a class="anchor" id="ac779a16f278c2a2310b427f02c65a934"></a><!-- doxytag: member="Surface::floodFill3" ref="ac779a16f278c2a2310b427f02c65a934" args="(pair&lt; pair&lt; int, int &gt;, int &gt; ind, pair&lt; int, int &gt; z_limits, pair&lt; int, int &gt; old_new, pair&lt; queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; *, queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; * &gt; queues, queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; *in_queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::floodFill3 </td>
          <td>(</td>
          <td class="paramtype">pair&lt; pair&lt; int, int &gt;, int &gt;&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>z_limits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>old_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; *, queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; * &gt;&#160;</td>
          <td class="paramname"><em>queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">queue&lt; pair&lt; pair&lt; int, int &gt;, int &gt; &gt; *&#160;</td>
          <td class="paramname"><em>in_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>inner routine for scanline </p>

</div>
</div>
<a class="anchor" id="a81bd694aaef6d8f81a3ec90fbada058e"></a><!-- doxytag: member="Surface::floodFill4" ref="a81bd694aaef6d8f81a3ec90fbada058e" args="(int ix, int iy, int iz, int idold, int idnew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::floodFill4 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>parallel version with scaline </p>

</div>
</div>
<a class="anchor" id="a8aae0c97bcbaa1f9d93877b0928d5c39"></a><!-- doxytag: member="Surface::getArea" ref="a8aae0c97bcbaa1f9d93877b0928d5c39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Surface::getArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total surface area </p>

</div>
</div>
<a class="anchor" id="a86dea6c9d55d6a873d3a9c0ce403aa9f"></a><!-- doxytag: member="Surface::getCavities" ref="a86dea6c9d55d6a873d3a9c0ce403aa9f" args="(int idStart=STATUS_POINT_TEMPORARY_OUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getCavities </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idStart</em> = <code>STATUS_POINT_TEMPORARY_OUT</code></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the cavities of the surface by grid flooding. A list of cavities is returned where each list is a list of triplet of indexes. It is up to the caller to free the memory of the int* pointers. The input decide wich is the first STATUS code to be checked. </p>

</div>
</div>
<a class="anchor" id="a13f6e6a853796495fe53e5820069000f"></a><!-- doxytag: member="Surface::getCavitiesAtoms" ref="a13f6e6a853796495fe53e5820069000f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getCavitiesAtoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>for each cavity/pocket detect the atoms that compose the cavity </p>

</div>
</div>
<a class="anchor" id="a4e9dd2a3cd7fdd85887727ed477f74aa"></a><!-- doxytag: member="Surface::getInsidness" ref="a4e9dd2a3cd7fdd85887727ed477f74aa" args="(int i, int j, int k, int vertInd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Surface::getInsidness </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return +1 if outside and -1 if inside for the vertex indexed by vertInd belonging to the grid cube given by i,j,k indexes </p>

</div>
</div>
<a class="anchor" id="a6abcfb3f49c88fc2874dd36242e73a14"></a><!-- doxytag: member="Surface::getProjection" ref="a6abcfb3f49c88fc2874dd36242e73a14" args="(double p[3], double *proj1, double *proj2, double *proj3, double *normal1, double *normal2, double *normal3)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::getProjection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>proj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>proj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>proj3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>normal1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>normal2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>normal3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a projection of a point on the surface. Return projection and normal </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#a75a338ecb29887d60a998e4e39cb371b">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#a1594a5d21afc2440f911396c9e3e3c4d">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#a1f0336ac4b845926683c3f8869702699">MeshSurface</a>, <a class="el" href="class_example_surface.html#a60d2008670f42c270ef6411428acbe0b">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#afa5931cb18223336f35264f3bbf68544">FVanDerWaalsSurface</a>, and <a class="el" href="class_external_surface.html#a5ca7d7fecef845d93e27056622fef711">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab726dc855b481fd5b7698027e7b18be1"></a><!-- doxytag: member="Surface::getRayIntersection" ref="ab726dc855b481fd5b7698027e7b18be1" args="(double p1[3], double p2[3], vector&lt; pair&lt; double, double * &gt; &gt; &amp;intersections, int thdID, bool computeNormals)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getRayIntersection </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; double, double * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>computeNormals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get all the intersections of a ray that goes from P1 to P2 over the surface. The interesctions are returned with increasing distance order. the double in the vector is the t parameter for the intersection of the parametric line and the surface, the double pointer is the normal vector. The management of the memory of the normal is up to the derived class from surface </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#a9d69fc62c0bdff2fab941a207ecd1a93">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#a6896369a48a092349654a0fd2ca56881">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#adf28935a0e9f2d9be032ac762651df7d">MeshSurface</a>, <a class="el" href="class_example_surface.html#a10b867cd6b48767cbf4f9a1cd32222e1">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a122477720762a10da7471e5d08d08ee4">FVanDerWaalsSurface</a>, and <a class="el" href="class_external_surface.html#ad65e100b545f96f653b1f56bc2148aef">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a61c7bc2bf53b083d34304632cf33d87c"></a><!-- doxytag: member="Surface::getSurf" ref="a61c7bc2bf53b083d34304632cf33d87c" args="(bool fill=false, double vol=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::getSurf </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillCav</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build DelPhi <a class="el" href="class_surface.html" title="Surface class is the general interface that a surface class should have to be plugged inside DelPhi...">Surface</a> by a specific method. If the defined surface provides at least projection and intersection routines then don't overload this function; it will already provide most of the information needed by DelPhi. The only restrictions are that only two dielectrics are allowed (in/out) and there is no Stern layer. Overload this method if the surface does not provide intersect or project or all information is needed. This mode of operation is used by the <a class="el" href="class_mesh_surface.html" title="This class represents a converter from an arbitray triangulated mesh surface to a DelPhi compatible r...">MeshSurface</a> class which provides getRayIntersection and getProjection primitives. If requested one can fill cavities by fill flag. In order to use parallel execution ray-tracing is performed using the itersectionFunctor</p>
<p>build epsmap and compute boundary grid points by intersection and projection routines. The minimal number of projections is performed. The ray tracing part is parallelized with boost threading if enabled </p>

<p>Reimplemented in <a class="el" href="class_external_surface.html#aea665a91caba02c16d6160325da7f3b8">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a44b184a84f4bb252cc1b9b60736c0946"></a><!-- doxytag: member="Surface::getTriangles" ref="a44b184a84f4bb252cc1b9b60736c0946" args="(double *vertexValues, double **vertexPos, double isolevel, int **triangles, int ix, int iy, int iz, int NX, int NY, int NZ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::getTriangles </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vertexValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>vertexPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>build triangles for marching cubes cell</p>
<p>Given a grid cell and an isolevel, calculate the triangular facets required to represent the isosurface through the cell. Return the number of triangular facets, the matrix triangles will be loaded up with the vertices at most 5 triangular facets. 0 will be returned if the grid cell is either totally above of totally below the isolevel. Can act using interpolation or querying the analytically computed intersection point. In this last case it is garanted that every point of the mesh belongs to the surface; ix,iy,iz are passed in order to query the intersection matrices </p>

</div>
</div>
<a class="anchor" id="a17a6ff105dde2aeb5298bf86b88fab63"></a><!-- doxytag: member="Surface::getVertices" ref="a17a6ff105dde2aeb5298bf86b88fab63" args="(double isolevel, int start_z, int end_z, int jump, vector&lt; coordVec &gt; *, vector&lt; double * &gt; *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::getVertices </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classcoord_vec.html">coordVec</a> &gt; *&#160;</td>
          <td class="paramname"><em>vertList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double * &gt; *&#160;</td>
          <td class="paramname"><em>normalsList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the vertices for a given section on z of the grid </p>

</div>
</div>
<a class="anchor" id="a6bdef0d8685e685849cccb1a463f68c0"></a><!-- doxytag: member="Surface::getVolume" ref="a6bdef0d8685e685849cccb1a463f68c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Surface::getVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the volume computed during <a class="el" href="class_surface.html#a61c7bc2bf53b083d34304632cf33d87c">Surface::getSurf</a> computations. This function can be overload to implement a custom volume computation method </p>

<p>Reimplemented in <a class="el" href="class_external_surface.html#a99fefd9c5ef61148f2642dfe3fd28157">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a4b74b0402a78369c8df85e6a6beaba93"></a><!-- doxytag: member="Surface::init" ref="a4b74b0402a78369c8df85e6a6beaba93" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>function for the constructor without arguments </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#a8453886922b9ea2b7d77889ef7baea2d">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#afc2f29c34fa4739dbbae66c111ba5adc">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#adde0415300bec8a69193cd5e99d8e80f">MeshSurface</a>, <a class="el" href="class_example_surface.html#a61a398442ec527ca3cdf88fccd46bc5d">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a62c6bafaadb947a453169205859d6fc0">FVanDerWaalsSurface</a>, <a class="el" href="class_external_surface.html#a7c1881cba4239c2e89e42db27b1f1db8">ExternalSurface</a>, <a class="el" href="class_coulombic_surface.html#a5971ee0f651b72d60205bc6d84216698">CoulombicSurface</a>, and <a class="el" href="class_blobby_surface.html#a32ed1baf7a5c8d129f9b90c62d61a63b">BlobbySurface</a>.</p>

</div>
</div>
<a class="anchor" id="afa9d3a3a984c8b576d2b9654546653aa"></a><!-- doxytag: member="Surface::init" ref="afa9d3a3a984c8b576d2b9654546653aa" args="(ConfigFile *cf)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::init </td>
          <td>(</td>
          <td class="paramtype">ConfigFile *&#160;</td>
          <td class="paramname"><em>cf</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>functions for the constructor with config file argument </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#ab10a5cf6385d8ddba010654e0b9032bc">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#a20a57517915ca49025417acd50fa2f85">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#aa079802ffb2a87cf28f8b41d3f71a245">MeshSurface</a>, <a class="el" href="class_example_surface.html#a6529d40a28028930b2e4b6b8a6e0f49e">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a81348db7148f61ec9b77d014f6347e95">FVanDerWaalsSurface</a>, <a class="el" href="class_external_surface.html#a7e8756f5d0d657e12d5dab6ac0c7d888">ExternalSurface</a>, <a class="el" href="class_coulombic_surface.html#afd885b7fd786a5d758fc88817d9d0ea2">CoulombicSurface</a>, and <a class="el" href="class_blobby_surface.html#a54449aa07af6b36387c4398fb8c0a038">BlobbySurface</a>.</p>

</div>
</div>
<a class="anchor" id="ab3e4ffdd402306e7ccba762b649f51ed"></a><!-- doxytag: member="Surface::innerFloodFill" ref="ab3e4ffdd402306e7ccba762b649f51ed" args="(int *start, int *target, short *status1, short *status2, int &amp;maxMoves, bool debug)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::innerFloodFill </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>status1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>status2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxMoves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>supports inner floodfill inside the 1.4 surface (given status1) to understand if two cavities/pockets are status2-linked (check external communication between two points by looking at status2 map). Gives true if the cavities/pockets comunicate and uses as input two random indices of two cavities/pockets. It stops if a maximal number of moves have been reached. A 'move' means moving from one grid point to another one. In max moves is returned the number of moves done to get the target. </p>

</div>
</div>
<a class="anchor" id="abb28f2e5b95b8f374ddd9232f7fb7574"></a><!-- doxytag: member="Surface::intersector" ref="abb28f2e5b95b8f374ddd9232f7fb7574" args="(double *volPanel, int nb, int start, int end, int jump, int *numIntersections, packet pack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::intersector </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>volPanel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>numIntersections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpacket.html">packet</a>&#160;</td>
          <td class="paramname"><em>pack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>intersector routine, used to perform partial or full intersections. Usefully used together with boost threading routines. In order to get a 'robust' ray tracer a particular strategy is adopted during ray-tracing. It can happen that, due to numerical imprecisions of the ray-intersection routine or due to problems of the surface (e.g. degenerate triangles, holes, non manifoldness in general) the number of detected intersections is odd. In this case the ray-tracer randomly perturbs the direction of the ray in order to escape from the singularity. If this strategy fails for a given number of trails, the trace of the previous ray is copied to the current one. <br/>
 In some cases this strategy can also fill small holes in the surface. </p>

</div>
</div>
<a class="anchor" id="a40e97c43ed07d2f0f0e6a05c2935f9c5"></a><!-- doxytag: member="Surface::linkCavities" ref="a40e97c43ed07d2f0f0e6a05c2935f9c5" args="(short *st1, short *st2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Surface::linkCavities </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>st1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>st2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If between two any cavities there is communication in map st2 and this communication is all internal in map st1 these cavities are merged logically. </p>

</div>
</div>
<a class="anchor" id="a8c76d22fd2fb86243d8c0462e1a93d40"></a><!-- doxytag: member="Surface::load" ref="a8c76d22fd2fb86243d8c0462e1a93d40" args="(char *fileName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::load </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the surface in a specific class dependent format. Return if loading was succesful or not </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#aaf9b2ee4bf6f26573ecd13aabafa822a">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#a4cfc24233ce51e12fc00c6e3c93ce0fb">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#a8e877815bf2cfe228b1f274ded891463">MeshSurface</a>, <a class="el" href="class_example_surface.html#a7a6e7f0c12b98b104a5e7c3ed1c3d807">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#ae7c7a614a07fcd64bd708197e12612ef">FVanDerWaalsSurface</a>, and <a class="el" href="class_external_surface.html#a474ceb824e390ec0c2861476e6f55e45">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="ae1129874da00ff0b1857591c0e179c6c"></a><!-- doxytag: member="Surface::operator&#45;=" ref="ae1129874da00ff0b1857591c0e179c6c" args="(Surface &amp;surf2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_surface.html">Surface</a> &amp; Surface::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_surface.html">Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>surf2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a Connolly regularized difference operator. Difference function is called and then Connolly filter is applied such that the noise can be filtered out. </p>

</div>
</div>
<a class="anchor" id="ae37064f017b7062b33d87de0c36b44cb"></a><!-- doxytag: member="Surface::postRayCasting" ref="ae37064f017b7062b33d87de0c36b44cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Surface::postRayCasting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this function is called after ray casting to perform any post processing, such as memory clean-up, after ray casting </p>

<p>Reimplemented in <a class="el" href="class_connolly_surface.html#a5f1c4a70237af1a3f99c3217309899a2">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#ad2308963fad301a29cef265bfe9ae908">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#a98b776f8492c099121cc8fdd24ea5355">MeshSurface</a>, <a class="el" href="class_example_surface.html#a2eac885e49ecc7bf565b6f5e4431ac11">ExampleSurface</a>, and <a class="el" href="class_f_van_der_waals_surface.html#ac315def10674b1e3d0893b59a5736a77">FVanDerWaalsSurface</a>.</p>

</div>
</div>
<a class="anchor" id="af36ad1f0f24d82f3f77837a1e28998b5"></a><!-- doxytag: member="Surface::preBoundaryProjection" ref="af36ad1f0f24d82f3f77837a1e28998b5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Surface::preBoundaryProjection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this function is called before boundary grid projection to perform any pre-processing, such as memory setup-up. </p>

<p>Reimplemented in <a class="el" href="class_connolly_surface.html#ac0e764714c04b3e9a7e0171d06ae8908">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#a7f8d8f28b6c089272aced52e13cc6268">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#a5ea865b9ef5a7131a7cfe6f8b7412e01">MeshSurface</a>, <a class="el" href="class_example_surface.html#a843000ed00ff3bbb12d3bb1f0efe30e2">ExampleSurface</a>, and <a class="el" href="class_f_van_der_waals_surface.html#a32026ea1ed688771725172cb1ac578a8">FVanDerWaalsSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a5f9846a6cd988af5aa352b7562636802"></a><!-- doxytag: member="Surface::preProcessPanel" ref="a5f9846a6cd988af5aa352b7562636802" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Surface::preProcessPanel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this function is called before the ray tracing of the panel. It can be useful if a per panel pre-processing step is needed. By default this function does nothing </p>

<p>Reimplemented in <a class="el" href="class_connolly_surface.html#a19605306c342bbb412b8b30e083d588d">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#acb71c21c45e6f13396959f10e6c6d2d1">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#ad60014094588acd77cd08f0379ab2256">MeshSurface</a>, <a class="el" href="class_example_surface.html#a780d8b19c4328c7051d578ff1424487f">ExampleSurface</a>, and <a class="el" href="class_f_van_der_waals_surface.html#ab2a225db17b0ffd456838da686a87548">FVanDerWaalsSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a301e2ea2fb4b9502f00095de103a462d"></a><!-- doxytag: member="Surface::printSummary" ref="a301e2ea2fb4b9502f00095de103a462d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::printSummary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print a summary of the surface type, status and other stuff </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#ac2ecb61add8a74f2d3d93942e5c5acd5">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#ab38e339baadb264aac6f432281285f46">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#aa1cd9954b8ea1c3c6c83e0bcdea682bb">MeshSurface</a>, <a class="el" href="class_example_surface.html#ae5cbb3445ca19df9d8129dd8f25acd5e">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a14de9f2a0813ecac529bc5621e7aee94">FVanDerWaalsSurface</a>, <a class="el" href="class_coulombic_surface.html#a8b2d82ec2685c3e1ecd614e124a64d28">CoulombicSurface</a>, <a class="el" href="class_blobby_surface.html#accc638fb7809195f681e11ca1ddba18a">BlobbySurface</a>, and <a class="el" href="class_external_surface.html#a5145fb8f436ecd9f0c38f83c3f4ab47f">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="aa1b0af28ebbd3078172873b403ae4b6b"></a><!-- doxytag: member="Surface::projector" ref="aa1b0af28ebbd3078172873b403ae4b6b" args="(int start, int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::projector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>projector routine, used to perform partial or full intersections. Usefully used together with boost threading routines </p>

</div>
</div>
<a class="anchor" id="add2db5e19f03a4d40fb8ead92833c439"></a><!-- doxytag: member="Surface::removeBackupStatus" ref="add2db5e19f03a4d40fb8ead92833c439" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::removeBackupStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>remove temporary status </p>

</div>
</div>
<a class="anchor" id="a2751d5daca6a1c766f8f8f6b34685177"></a><!-- doxytag: member="Surface::save" ref="a2751d5daca6a1c766f8f8f6b34685177" args="(char *fileName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::save </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Save the surface in a specific class dependent format. Return if saving was succesful or not </p>

<p>Implemented in <a class="el" href="class_connolly_surface.html#ac2afe81ed1601e274881a492a4559b5e">ConnollySurface</a>, <a class="el" href="class_skin_surface.html#ad975eab3a6101bea1e9783ba4f30ad1a">SkinSurface</a>, <a class="el" href="class_mesh_surface.html#aece511a3a2092ff7a50b88a0caafc105">MeshSurface</a>, <a class="el" href="class_example_surface.html#ae5373bc46dda2ec73e91022b24791ecf">ExampleSurface</a>, <a class="el" href="class_f_van_der_waals_surface.html#a9930754cb5cce3bf435593e234e16eda">FVanDerWaalsSurface</a>, and <a class="el" href="class_external_surface.html#aad1571d55beee2fb8ebe271119443ce8">ExternalSurface</a>.</p>

</div>
</div>
<a class="anchor" id="a6f52710c2460260d5342eb55060894e6"></a><!-- doxytag: member="Surface::saveMesh" ref="a6f52710c2460260d5342eb55060894e6" args="(int format, bool revert, const char *fileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::saveMesh </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>revert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>save mesh in a prescribed format, revert triangles (change plane sign) if requested </p>

</div>
</div>
<a class="anchor" id="a5a062749214cb7121ecab66ce979e163"></a><!-- doxytag: member="Surface::setProjBGP" ref="a5a062749214cb7121ecab66ce979e163" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::setProjBGP </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set if surface has to project bgp or not. During cavity detection/surface visualization/triangulation bgp projection can be skipped </p>

</div>
</div>
<a class="anchor" id="a30601580f9e6867aa9ee290378f9855b"></a><!-- doxytag: member="Surface::smoothSurface" ref="a30601580f9e6867aa9ee290378f9855b" args="(const char *fn=&quot;triangulatedSurf&quot;, bool revert=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::smoothSurface </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fn</em> = <code>&quot;triangulatedSurf&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>revert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>smooth a given mesh and overwrites the given file name. The input/output mesh is in .off format </p>

</div>
</div>
<a class="anchor" id="ab33c17df0587ec8fac0c43130cde651b"></a><!-- doxytag: member="Surface::swap2multi" ref="ab33c17df0587ec8fac0c43130cde651b" args="(double gxmin, double gymin, double gzmin, double gside, unsigned int ggrid, int *gridMultiMap, int i, int j, int k, int l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::swap2multi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gxmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gzmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ggrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>gridMultiMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>swap the state of a point in the epsmap from internal to the nearest atom dielectric </p>

</div>
</div>
<a class="anchor" id="a1e23cf166678a10006927c0753d754e3"></a><!-- doxytag: member="Surface::tri2Balls" ref="a1e23cf166678a10006927c0753d754e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::tri2Balls </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>translate a triangulation (a set of samples) into a set of balls (ray-casting sampling + power crust) </p>

</div>
</div>
<a class="anchor" id="a05ae5d8c757297d2e71fcd15171957fb"></a><!-- doxytag: member="Surface::triangulateSurface" ref="a05ae5d8c757297d2e71fcd15171957fb" args="(double iso=0.0, const char *fileName=&quot;triangulatedSurf&quot;, bool revert=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Surface::triangulateSurface </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iso</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em> = <code>&quot;triangulatedSurf&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>revert</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Triangulate the surface and save it in OFF format. In the <a class="el" href="class_surface.html" title="Surface class is the general interface that a surface class should have to be plugged inside DelPhi...">Surface</a> class the baseline method for triangulation is obtained by employing the marching cube method at each delphi grid cell. For each vertex in the grid cube its insideness is computed by voting of the insidness values of the incident cubes; thus the scalar field is given by the ensemble of the status map. The surface is saved in off format </p>
<p>check atoms flag </p>

</div>
</div>
<a class="anchor" id="a37ccecb59c1809f99a642836fc3a85b9"></a><!-- doxytag: member="Surface::triangulationKernel" ref="a37ccecb59c1809f99a642836fc3a85b9" args="(double isolevel, bool revert, int start_z, int end_z, int jump, vector&lt; int * &gt; *localTriList, double *localArea)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Surface::triangulationKernel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>revert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>jump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int * &gt; *&#160;</td>
          <td class="paramname"><em>localTriList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>localArea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>triangulator thread </p>

</div>
</div>
<a class="anchor" id="aead8b30ad88724d4542ee01bc5bef037"></a><!-- doxytag: member="Surface::vdwAccessible" ref="aead8b30ad88724d4542ee01bc5bef037" args="(double *p, int &amp;nearest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Surface::vdwAccessible </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nearest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>gives true if the point is outside vdw surface </p>

</div>
</div>
<a class="anchor" id="a90a0436c049d155f2c9c4c46a564a660"></a><!-- doxytag: member="Surface::vertexInterp" ref="a90a0436c049d155f2c9c4c46a564a660" args="(double isolevel, double *p1, double *p2, double valp1, double valp2, double *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Surface::vertexInterp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>valp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>valp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>marching cubes vertex interpolation </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6c45be42398b0f466b9a4e2af961ea06"></a><!-- doxytag: member="Surface::activeCubes" ref="a6c45be42398b0f466b9a4e2af961ea06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool* <a class="el" href="class_surface.html#a6c45be42398b0f466b9a4e2af961ea06">Surface::activeCubes</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>mark wich MC cubes contain triangles to allow fast reject in the second pass </p>

</div>
</div>
<a class="anchor" id="a8e1c15969548e4d1230904b87ff73b0c"></a><!-- doxytag: member="Surface::bgp_type" ref="a8e1c15969548e4d1230904b87ff73b0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="class_surface.html#a8e1c15969548e4d1230904b87ff73b0c">Surface::bgp_type</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>type of bgp for each detected bgp </p>

</div>
</div>
<a class="anchor" id="a574488ee98ebef52bb6fa4d25d8e9c34"></a><!-- doxytag: member="Surface::checkDuplicatedVertices" ref="a574488ee98ebef52bb6fa4d25d8e9c34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_surface.html#a574488ee98ebef52bb6fa4d25d8e9c34">Surface::checkDuplicatedVertices</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>if enabled loaded surface is checked for duplicated vertices </p>

</div>
</div>
<a class="anchor" id="a6b6bee2350f00c90e92ee0c9f1d82141"></a><!-- doxytag: member="Surface::gridLoad" ref="a6b6bee2350f00c90e92ee0c9f1d82141" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="class_surface.html#a6b6bee2350f00c90e92ee0c9f1d82141">Surface::gridLoad</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pointer to a vector which holds the information about the load for each grid slice </p>

</div>
</div>
<a class="anchor" id="a45d8207ef5dc33d9f58f75658f293489"></a><!-- doxytag: member="Surface::gridMultiMap" ref="a45d8207ef5dc33d9f58f75658f293489" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="class_surface.html#a45d8207ef5dc33d9f58f75658f293489">Surface::gridMultiMap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>grid multi-dielectric map </p>

</div>
</div>
<a class="anchor" id="a4a0e0047b72f2cbd187389f01d69b3c3"></a><!-- doxytag: member="Surface::inside" ref="a4a0e0047b72f2cbd187389f01d69b3c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_surface.html#a4a0e0047b72f2cbd187389f01d69b3c3">Surface::inside</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DelPhi code for inside. </p>

</div>
</div>
<a class="anchor" id="a98714879238042d7515497fbd78e0e85"></a><!-- doxytag: member="Surface::intersectionsMatrixAlongX" ref="a98714879238042d7515497fbd78e0e85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Octree&lt;int&gt;* <a class="el" href="class_surface.html#a98714879238042d7515497fbd78e0e85">Surface::intersectionsMatrixAlongX</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d matrix of intersections along x rays </p>

</div>
</div>
<a class="anchor" id="ae5d6e25842d3f00ed491bc3fd5508820"></a><!-- doxytag: member="Surface::intersectionsMatrixAlongY" ref="ae5d6e25842d3f00ed491bc3fd5508820" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Octree&lt;int&gt;* <a class="el" href="class_surface.html#ae5d6e25842d3f00ed491bc3fd5508820">Surface::intersectionsMatrixAlongY</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d matrix of intersections along y rays </p>

</div>
</div>
<a class="anchor" id="ae1277d3fa42afd57392d99892d262e3a"></a><!-- doxytag: member="Surface::intersectionsMatrixAlongZ" ref="ae1277d3fa42afd57392d99892d262e3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Octree&lt;int&gt;* <a class="el" href="class_surface.html#ae1277d3fa42afd57392d99892d262e3a">Surface::intersectionsMatrixAlongZ</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d matrix of intersections along z rays </p>

</div>
</div>
<a class="anchor" id="a6c2895b91dee0cb779c5f623b95e5fb9"></a><!-- doxytag: member="Surface::isRCbased" ref="a6c2895b91dee0cb779c5f623b95e5fb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_surface.html#a6c2895b91dee0cb779c5f623b95e5fb9">Surface::isRCbased</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>every class at Constructor time must say if it is Ray Casting based or not If it is ray casting based than getSurf will derive the grid based on ray casting if not RC based getSurf will assume that build method has already coloured the grid </p>

</div>
</div>
<a class="anchor" id="a788497ff41d053c1b9ead2708651a356"></a><!-- doxytag: member="Surface::normalsList" ref="a788497ff41d053c1b9ead2708651a356" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;double*&gt; <a class="el" href="class_surface.html#a788497ff41d053c1b9ead2708651a356">Surface::normalsList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>vector of normal to vertices </p>

</div>
</div>
<a class="anchor" id="a326788a7b067f52c07753504e04396db"></a><!-- doxytag: member="Surface::normalsMatrixAlongX" ref="a326788a7b067f52c07753504e04396db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Octree&lt;int&gt;* <a class="el" href="class_surface.html#a326788a7b067f52c07753504e04396db">Surface::normalsMatrixAlongX</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d matrix of normals along x rays </p>

</div>
</div>
<a class="anchor" id="add2c136b467697e7a7da833cd76283be"></a><!-- doxytag: member="Surface::normalsMatrixAlongY" ref="add2c136b467697e7a7da833cd76283be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Octree&lt;int&gt;* <a class="el" href="class_surface.html#add2c136b467697e7a7da833cd76283be">Surface::normalsMatrixAlongY</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d matrix of normals along y rays </p>

</div>
</div>
<a class="anchor" id="aff65b5bcd2ef767b8725b8aa9c2211d6"></a><!-- doxytag: member="Surface::normalsMatrixAlongZ" ref="aff65b5bcd2ef767b8725b8aa9c2211d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Octree&lt;int&gt;* <a class="el" href="class_surface.html#aff65b5bcd2ef767b8725b8aa9c2211d6">Surface::normalsMatrixAlongZ</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>3d matrix of normals along z rays </p>

</div>
</div>
<a class="anchor" id="aee9146cf4f2d57f70221153bb2a9b9cc"></a><!-- doxytag: member="Surface::probe_radius" ref="aee9146cf4f2d57f70221153bb2a9b9cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_surface.html#aee9146cf4f2d57f70221153bb2a9b9cc">Surface::probe_radius</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Probe radius. Currently used in the cavity shape filter </p>

</div>
</div>
<a class="anchor" id="a1443e3d35892254a47633f1df92a8430"></a><!-- doxytag: member="Surface::providesAnalyticalNormals" ref="a1443e3d35892254a47633f1df92a8430" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_surface.html#a1443e3d35892254a47633f1df92a8430">Surface::providesAnalyticalNormals</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>every surface at constructor time must say if it will provide analytical normals during ray tracing or not </p>

</div>
</div>
<a class="anchor" id="a4632ae2d850db8721d1a047159034c0d"></a><!-- doxytag: member="Surface::randDisplacement" ref="a4632ae2d850db8721d1a047159034c0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_surface.html#a4632ae2d850db8721d1a047159034c0d">Surface::randDisplacement</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>how big is the random initial displacement of atoms </p>

</div>
</div>
<a class="anchor" id="a70a2e5e21c918060a90ebeff6d4d845e"></a><!-- doxytag: member="Surface::surfType" ref="a70a2e5e21c918060a90ebeff6d4d845e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_surface.html#a70a2e5e21c918060a90ebeff6d4d845e">Surface::surfType</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>says if the surface represents a molecule, an hybrid system or an object </p>

</div>
</div>
<a class="anchor" id="aab49d3b34cdd33528617da0a4efc62d0"></a><!-- doxytag: member="Surface::triList" ref="aab49d3b34cdd33528617da0a4efc62d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int*&gt; <a class="el" href="class_surface.html#aab49d3b34cdd33528617da0a4efc62d0">Surface::triList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>vector of vertex indices for the traingulation obtained by triangulateSurface function </p>

</div>
</div>
<a class="anchor" id="aefcae5a542a8333a04babe1ba7931b19"></a><!-- doxytag: member="Surface::vertList" ref="aefcae5a542a8333a04babe1ba7931b19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;double*&gt; <a class="el" href="class_surface.html#aefcae5a542a8333a04babe1ba7931b19">Surface::vertList</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>vector of triangle vertices </p>

</div>
</div>
<a class="anchor" id="a4fe91bf0a47526c32f1b4b28cef45439"></a><!-- doxytag: member="Surface::wellShaped" ref="a4fe91bf0a47526c32f1b4b28cef45439" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_surface.html#a4fe91bf0a47526c32f1b4b28cef45439">Surface::wellShaped</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>if enabled the part of the cavities (or the entire cavities) that are not shaped as a water molecule are removed </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Documents and Settings/sdecherchi/My Documents/Ricerca/software nostro/NanoShaper0.7/src/<a class="el" href="_surface_8h_source.html">Surface.h</a></li>
<li>C:/Documents and Settings/sdecherchi/My Documents/Ricerca/software nostro/NanoShaper0.7/src/<a class="el" href="_surface_8cpp.html">Surface.cpp</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_surface.html">Surface</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Tue Nov 5 2013 16:31:35 for NanoShaper by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
